'''
문제 설명
주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 ICN 공항에서 출발합니다.

항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한사항
모든 공항은 알파벳 대문자 3글자로 이루어집니다.
주어진 공항 수는 3개 이상 10,000개 이하입니다.
tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.
주어진 항공권은 모두 사용해야 합니다.
만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.


link : https://programmers.co.kr/learn/courses/30/lessons/43164
'''

'''
백트레킹의 대표적인 문제
==> dfs, bfs를 진행하다 틀린 경우를 발견할 경우 나머지는 확인하지 않고 이전으로 돌아가 다시 탐색

0 0 0 0                         
0 0 0 0  가 있다고 가정할 경우,
0 0 0 0  첫 번째 줄부터 가능한 경우인지 판단하면서, 가능할 경우만 그 다음줄을 탐색함
0 0 0 0 

1 0 0 0 => o
1 0 0 0 => x

1 0 0 0 => o
0 1 0 0 => x

1 0 0 0 => o
0 0 1 0 => o
1 0 0 0 => x

1 0 0 0 => o
0 0 1 0 => o
0 1 0 0 => x

1 0 0 0 => o
0 0 1 0 => o
0 0 1 0 => x

1 0 0 0 => o
0 0 1 0 => o
0 0 0 1 => x

1 0 0 0 => o
0 0 0 1 => o
1 0 0 0 => x

1 0 0 0 => o
0 0 0 1 => o
0 1 0 0 => o
1 0 0 0 => x
....

위 로직을 보면 알 수 있지만 어차피 퀸은 한 줄에 하나만 존재할 수 있고,
그렇기에 각 퀸의 위치를 숫자로 표현할 수 있다.

0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0

==> [1, 3, 0, 2] 
(첫번째 줄의 두번째 위치, 두번째 줄의 네번째 위치, 세번째 줄의 첫번째 위치, 네번째 줄의 세번째 위치)
'''

def chess(row, col, n) :
    global answer

    # 현재 퀸들이 놓여진 것이 가능한 경우인지를 판단하는데,
    # row가 0일 경우(첫 번째 행의 경우) 퀸이 하나밖에 없기에 무조건 가능하다.
    check = True
    for i in range(row) :
        # row가 2일 경우부터는 가능한 경우인지 판단해야 하는데,
        # 어차피 한 줄에 하나씩만 퀸이 놓여져있기 때문에 행간은 비교하지 않고,
        # col[row] == col[i] (현재 행의 퀸의 값(위치)와 같은 열에 놓여진 퀸이 있는지(col에 col[row]와 같은 숫자가 있는지)를 판단)
        # (abs(col[row] - col[i]) == row - i (행간의 위치 차이와 열간의 위치 차이가 같은 경우 (대각선에 놓여진 경우)인지)
        # 판단하여 그럴 경우 check를 False로 변경하고 break 한다.
        if (col[row] == col[i]) or (abs(col[row] - col[i]) == row - i) :
            check = False
            break

    if check :
        # 가장 최근에 놓은 퀸의 위치가 마지막 행인 경우 answer에 +1을 한다.
        if row == n-1 :
            answer += 1

        # 마지막줄이 아닐 경우 다음 줄에 0번 위치부터 퀸을 놓으며 위 과정을 다시 진행한다.
        else :
            for i in range(n) :
                col[row+1] = i # 다음 줄에 퀸을 놓고
                chess(row+1, col, n) # 방금 놓은 퀸으로 가능한 위치인지 판단해가며 다시 로직 실행

def solution(n) :
    global answer
    answer = 0

    # 각 줄의 퀸의 위치를 표현할 수 있도록 0으로 이루어진 list를 생성한다.
    col = [0 for _ in range(n)]


    # chess 함수를 다음 행에 퀸을 놓고 난 뒤 비교하는 함수로 로직을 구성할 것이기 때문에
    # 0번 index(첫 번째 행)부터 퀸을 놓을 것이기에 row를 -1로 하여 chess함수를 시작한다.
    chess(-1, col, n)

    return answer

print(solution(4))
    